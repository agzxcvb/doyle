//const {nodeJsF} = requir(./javascriptMethod.html)
//파일 불러오기 = require(./파일명.js);

//JS 에서는 <script src="파일명">을통해 변수를 불러올 수 있다.
//실수를 방지하기위해서는 
//비구조화 할당으로 다른 파일의 변수를 불러올 수 있다
//단, 객체 속성만 가능하다. 
//const { odd, even} = require(./파일명.js) //여러가지 가능
//단, 불림을 당하는 파일도 코드가 필요하다. 마지막에 
//module.export = {odd, even}; / 불러온 파일에서 똑같이 또 내보낼 수 있다.
// //var.js******************************
// const odd = 1; const eve=2;
// module.export = {odd, evne};
// //func.js*****************************
// const {odd, even} = require(./var.js);
// console.log(odd);
// console.log(even);
// module.export = {odd, even};

//****************************************************************************************************** */
//console 메서드

// const sttring = 'abc';
// const number = 1;
// const bool = true;
// const object = {
//     outside : {
//         inside :{ //depth : 1
//             key: 'value', //depth : 2
//         }
//     },
// };

// console.time('전체시간'); //인자에 따라 end 된다.
// console.log('로그 , 쉼표 구분가능');
// console.log(sttring, number, bool);

// console.error('에러 값을 찍는 로그');

// console.dir(object, {color : false, depth : 1});
// console.dir(object, {color : true, depth : 2});

// console.time('시간측정');
// for(i = 0; i <100000; i++){
//     continue;
// } //진행 시간을 늦춰보기 위한 for문 사용
// console.timeEnd('시간측정');


// function a(){
//     b();
// }

// function b(){
//     console.trace('에러위치');
// }
// a();

// console.timeEnd('전체시간')
//****************************************************************************************************** */
//타이머 메서드 비동기적 함수 사용을 위해 반드시 필요하다.

// const timeout = setTimeout(() => {
//     console.log('1초 후 실행');
// }, 1000);

// const interval = setInterval(() => {
//     console.log('2초 마다 실행');
// }, 2000);


// setTimeout(()=>{
//     clearTimeout(timeout);
//     clearInterval(interval);
// }, 3000);

// const immediate = setImmediate(() =>{
//     console.log('즉시실행')
// });

// clearImmediate(immediate);

// const Immediate2 = setImmediate(()=>{
//     console.log('두번째 즉시실행_마지막행'); //노드에서 즉시사용할 타임을 건다면 setTimout(callback,0)이 아닌 해당 Immediate()를 사용한다.
// })

//****************************************************************************************************** */
//__firlename / __dirname
//파일사이에 모듈관계가 있는경우(require, export)가 많기 떄문에 현재 파일의 경로나, 파일명을 확인하기 위해 많이 쓰인다.

// console.log(__filename); //해당 파일명
// console.log(__dirname); //해당 파일이 속해있는 폴더명

//****************************************************************************************************** */
//process
//현재 실행되고 있는 노드프로세스에 대한 정보를 담고있다. /노드에서 직접실행
//process.version / 설치된 노드 버전
//process.arch /프로세서 아키텍처
//process.platform / 운영체제
//process.pid /현재 프로세서 ID / 프로세서를 여러개 사용할 때 구분할 수 있다.
//process.uptime() / 노드를 사용한 시간
//process.execPath /노드의 경로
//process.cwd() /현재 프로세스가 실행되고 있는 위치
//process.cpuUsage() /현재 CPU 사용량

//process.env *******************************다시공부******************************************************
//서비스의 중요정보를 저장하는 공간
//사용자 ID, PW 등 각종 API 를 코드에 넣을 수 없다.
// const secretId = process.env.SECRET_ID;
// const secretCode = process.env.SECRET_CODE;
// 이제 값을 넣으면 된다.

//****************************************************************************************************** */
//process.nextTick(콜백) / 
//마이크로태스크를 재귀 호출하게 되면 이벤트 루프는 다른 콜백함수 보다 우선하여 처리하므로
//콜백 함수들이 실행되지 않을 수도 있다.
//가급적 setImmediate(콜백)을 쓰도록 하자

//****************************************************************************************************** */
//process.exit(); 노드 종료
// let i = 1;
// setInterval (()=>{
//     if(i===4){ // 4번 반복되어 3까지 출력 후 4일때 종료  
//         console.log('종료');
//         process.exit();
//     }
//     console.log(i);
//     i += 1;
// }, 1000);
//****************************************************************************************************** */
//OS 노드는 os까지 접근이 가능하다 PC프로그램 짤때 사용한다.
//단 os.cups 를 사용하여 반복문을 통해 프로세스를 넣는다.
//싱글스레드를 극복하는 방법 ->멀티 프로세싱
// os.cpus().length 가 코어의 갯수이다.
//os.constants() 각종 에러와 신호가 들어있는데
//운영체제별로 다른 서비스를 보여주려할때 활용된다.

//****************************************************************************************************** */
//****************************************************************************************************** */
//****************************************************************************************************** */
//PATH 굉장히 중요하다

// const path = require('path');
// console.log(path.sep); //경로 구분자(디렉토리 경로 구분자) \, 리눅스 or 맥 /
// console.log(path.delimiter); // ; 환경변수 구분자(node, npm등의 명령어를 칠 수 있는 이유: 프로그램 경로가 환경변수에 담겨있기 떄문)) 
// console.log(path.dirname(__filename)); //파일의 경로
// console.log(path.extname(__filename)); //파일의 확장자 이름
// console.log(path.basename(__filename)); //파일명.확장자 이름
// console.log(path.parse(__filename)); //객체로 분할
// // console.log(path.format({root:oo, :, :, :}})); //parse 로 분해된 값을 format으로 합쳐준다.

// console.log(path.normalize('C://user/user')); // 경로구분자를 잘못 치고 있었다면 제대로 만들어준다.

// console.log(path.isAbsolute('C://')); //상대 경로인가 아닌가 ./ ../인가 절대경로면 true
// console.log(path.relative('c://user/user', 'F://')); //첫번째에서 두번째까지의 상대 경로를 출력한다. 유용

// console.log(path.join(__dirname, '..','..')); //조각난 경로들의 절대 경로를 무시하고 합쳐준다.
// console.log(path.resolve(__dirname,'..','..')); //결대 경로를 고려하고 합친다. 

//****************************************************************************************************** */
//URL 서버에 요청 보낼때도 주소를 통해 요청을 전달한다.
//URL 은 여러 구조가 있다. / 자유 자제로 분해가능한 모듈
//구버전과 신버전이있는데 두가지다 사용해야한다.
//구버전의경우 같은 호스팅일 경우 호스트를 지운다 -> 인스턴스생성 -> 신버전(WHATWG) -> toString() 사용가능한 주소로 만든다.

// console.log('기본적인 URL 작성법')

// const url = require('url');

// const URL = url.URL
// const myURL = new URL('http://www.giltbut.co.kr/book/booklist.aspx?sercate1=001001000#anchor');

// console.log('new URL():', myURL); //객체로 출력했으므로 합치기 위해 format
// console.log('url format : ', url.format(myURL));
// console.log('---------------------------------');
// const parseURL = url.parse('http://www.giltbut.co.kr/book/booklist.aspx?sercate1=001001000#anchor');
// console.log('parseURL : ', parseURL);
// console.log('url.format() : ', url.format(parseURL));
// console.log('---------------------------------');

// //URL searchParams 다루기
// const url = require('url');

// const URL = url.URL;
// const myURL = new URL('http://www.giltbut.co.kr/?page=3&limit=10&category=nodejs&category=javascrupt');

// console.log('searchURL : ', myURL.searchParams); //객체로 key => value 가 출력된다.
// console.log('searParams.getAll : ', myURL.searchParams.getAll('category')); //category가 두개였는데 두개 모두의 값을 배열로 담는다.
// console.log('searchParams.get(1) : ', myURL.searchParams.get('category')); //get은 category의 첫번째 값만 가져온다
// console.log('searchParams.get(2) : ', myURL.searchParams.get('limit')) //10
// console.log('searchParams.has() : ', myURL.searchParams.has('page')); //키가 있으면 true

// console.log('searchParams.key() : ', myURL.searchParams.keys()); //키들을 객체로 가져온다.
// console.log('searchParams.value() : ', myURL.searchParams.values()); //값들을 객체로 가져온다.

// myURL.searchParams.append('filter', 'es3'); //'키', '값'을 추가한다.
// console.log(myURL);
// myURL.searchParams.set('filter','es5'); //기존 키의 값을 수정한다.
// console.log(myURL);
// myURL.searchParams.delete('filter'); //'키'값을 넣으면 지울 수 있다.
// console.log(myURL);

// console.log('searchParams.toString() : ', myURL.searchParams.toString()); //파라미터값만 사용가능한 내용으로 수정한다.

// myURL.search = myURL.searchParams.toString();
// console.log(myURL.search); //?page=3&limit=10&category=nodejs&category=javascrupt

//****************************************************************************************************** */
// //querystring / URL의 쿼리부분을 편리하게 사용하기 위해서 쓴다.
// const url = require('url');
// const quertstring = require('querystring');

// const parseURL = url.parse('http://www.giltbut.co.kr/?page=3&limit=10&category=nodejs&category=javascrupt'); //url중 host 이후 부분만 파싱한다.
// const query = quertstring.parse(parseURL.query); //그중 쿼리부분만 다시 파싱한다.
// console.log('queryString.parse() : ', query);// 쿼리부분 // ? 이후  / 중복은 배열로 출력한다.
// console.log('quertstring.stringify() : ', quertstring.stringify(query)); //파싱한 객체를 문자열로 바꾼다.

//****************************************************************************************************** */
//암호화 나중에 사용되는 알고리즘으로 다시 코딩

//****************************************************************************************************** */
//utill 모듈 / 각종 편의기능을 지원한다, 단, deprecated 되어 사라지는 경우도 있다.
//암호화 - util 중 promise를 사용가능하게 하는 것을 융합

// const crypto = require('crypto');
// const util = require('util');

// //암호화 방법


// crypto.randomBytes(64, (err, buf) =>{
//     const salt = buf.toString('base64');
//     console.log('salt :', salt);
    
//     console.time('암호화 시간'); //1초대
    
//     crypto.pbkdf2('도트', salt, 1004395, 64, 'sha512', (err,key) =>{
//         console.log('password : ', key.toString('base64'));
//         console.timeEnd('암호화 시간');
//     });
// });


// const randomBytesPromise = util.promisify(crypto.randomBytes); //util을 통해 콜백만 가능한 함수를 promise로 사용 할 수 있다.
// const pbkdf2Promise = util.promisify('crypto.pbkdf2');
// randomBytesPromise(64)
//     .then((buf) => {
//         const salt = buf.toString('base64');
//         return pbkdf2Promise('도트', salt, 651395, 64, 'sha512');
//     })
//     .then((key) =>{
//         console.log('password : ', key.toString('base64'));
//     })
//     .catch((err) => {
//         console.error(err);
//     });

//나아가 aync await 문으로 간단하게 변경할 수 있다.

// (async () =>{
//     const buf = await randomBytesPromise(64);
//     const salt = buf.toString('base64');
//     const key = pbkdf2Promise('도트', salt, 651395, 64, 'sha512');
//     console.log('password', key.toString('base64'));
// })();

//****************************************************************************************************** */
//3.6 파일 시스템 접근하기



//****************************************************************************************************** */
//****************************************************************************************************** */
//****************************************************************************************************** */
//****************************************************************************************************** */
//****************************************************************************************************** */
//****************************************************************************************************** */
//****************************************************************************************************** */
