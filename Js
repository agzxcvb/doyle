<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Javascript Study</title>
</head>
<body>
<!-- 스크립트 기본 메서드 -->
<script>
// class Kim {
//     constructor(){
//         this.name = 'doyle';
//         this.height = 190;
//     }
// }

// var person = new Kim();


//**********************************************************************
// //객체 또는 배열을 열거 할 수 있는지 확인함

// console.log(person.propertyIsEnumerable('name'));


//**********************************************************************
//.toString() 객체를 문자열로 변환한다.
//객체를 문자로 변환하고 / 공백을 잘라서 배열로 사용하고 / 빈값은 제거함
// var textinner = Kim.toString().split(" ");
// var nertextinner = new Array(textinner);
// for(var i = 0; i < textinner.length ; i ++){
//     if(textinner[i] === ""){
//         delete textinner[i];
//     }
//     else{
//     document.write(textinner[i] + '<br/>');
//     }
// }
// document.write(i);

// var a = { name : 1};
// // console.log(a.toString()); /[obj obj]
// // document.write(a.toString()); /[obj obj]

// console.log(a.name.toString()); // 1
// document.write(a.name.toString()); // 1

//***************************************************************
//.toLocaleString(); /타국 언어 또는 사용자 지정으로 변경할 수 있다.

// var a = {name : 111111,};
// document.write(a.name.toLocaleString()); // 111,111
// console.log(a.name.toLocaleString()); // 111,111

// var number = 1234;
// document.write(number.toLocaleString()); /지정값이 없다면 기본적용된 스타일로 나온다
// console.log(number.toLocaleString()); /지정값이 없다면 기본적용된 스타일로 나온다

//***************************************************************
//객체내 프로퍼티를 사용 가능한지 bool을 통해 리턴한다.

// var a = {name : 'kim'};
// document.write(a.hasOwnProperty('name'));
// console.log(a.hasOwnProperty('name'));
//***************************************************************
//배열 또는 객체의 값을 출력한다.
// var p1 = {
//     width : 'kim',
// }
// document.write(p1.valueOf());
// document.write(p1.width.valueOf());

// console.log(p1.valueOf()); // {width : 100}
// console.log(p1.width.valueOf()); // 100


//***************************************************************
//***************************************************************
//***************************************************************

//문자열의 문자를 배열화시켜서 index에 맞춰 출력한다**********************************
//charAt(index) index 값에 있는 문자를 출력한다
/*  
var obAt = {
    name : 'sin',
}
console.log(obAt.name.charAt(4)); //빈칸으로 출력한다
*/

// var a = "abcd";
// var b = a.charAt(4);
// document.write(b);
// console.log(b);

//찾는 문자의 유니코드값을 리턴한다.
// var a = 'abc'
// var b = a.charCodeAt(0);

// document.write(b);
// console.log(b);


//문자열에 있는 값을 찾아서 없으면 -1을 리턴한다
/*
var str = 'Sin';
document.write(str.indexOf('S',0)); //0번째 index에 S 가 있었다.//0
console.log(str.length);

var objstr = {
    name : 'sin',
}
document.write(objstr.indexOf('name',0));
*/

// var a = "abcdabcd";
// var b = a.indexOf("a");
// console.log(b);
// document.write(b);

// var c = a.indexOf("a", 3);
// console.log(c);
// document.write(c);

// var d = a.indexOf("q");
// console.log(d);
// document.write(d);

// var l = a.lastIndexOf("b");
// console.log(l);
// document.write(l);



//***************************************************************
// Match(value)
//문자열이 정규식과 매치되는 '첫' 부분을 검색합니다.
//존재한다면 찾는 값을 그대로 리턴한다.

/*
var str = 'For more information, see Chapter 3.4.5.1';
var re = 'F';
var found = str.match(re);
document.write(found); //F
document.write(found.index); //index: 0 /한글자씩 쪼개며 s가 시작되는 index를 뽑아낸다.
console.log(found);

var str = "Nothing will come of nothing.";
var found2 = str.match();   
document.write(found2); //0
document.write(found2.index); //index: 0 /매개변수가 없을때
console.log(found2);
*/

// var a = "abc";
// document.write(a.match('a'));
// console.log(a.match("a"));
// document.write(a.search('a'));
// console.log(a.search("a"));
//***************************************************************
// replace('변경전값', '변경할값')
//문자열 중 선택한 값이 있다면 교체할 수 있도록 함.
// var str = 'Twas the night before Xmas...';
// document.write(str+'<br/>'); 
// document.write('<br/>'+ '문자열 치환' + str);
// var newstr = str.replace('i', 'i:(Christmas)');
// document.write('<br/>'+ '문자열 치환' + newstr);
// var innertext = "mt wife teayeon.Kim";
// document.write('<br/>'+ '문자열 치환' + innertext);

// //배열에서는 replace 불가능 / index로 변경하면됨
// var a = [1,2,3,4];
// a[0] = 2;
// console.log(a);

// // var arrayReplace1 = a.replace(1, 11);
// // var arrayReplace2 = a[0].replace(1, 11);
// // var arrayReplace3 = a.replace(a[0], 11);
// // document.write('<br/>'+ '문자열 치환' + arrayReplace1);
// // document.write('<br/>'+ '문자열 치환' + arrayReplace2);
// // document.write('<br/>'+ '문자열 치환' + arrayReplace3);
// // var arrayText = a.valueOf();
// // document.write('<br/>' + '배열을 문자열로 출력할뿐 타입자체가 변경되는 것은 아니다' + arrayText);
// // console.log(arrayText.constructor); //타입은 Array()
// var a  = "mt Sin";
// document.write(a.replace("mt", "my"));
// console.log(a.replace("mt", "my"));

// //객체에서도 불가능
// var obj = {a:1, b:2};
// var objtest = obj.replace('a','c');
// document.write(objtest);

// //어법에 맞지않지만 확인을 위해 t를 중복으로 사용해봤다. 
// var newinnertext = innertext.replace('mt', 'my').replace('te','Te');
// //연속 치환은 이어서 가능하며, 함수로 쓰면 편리하다.***************************************************************미숙
// document.write(newinnertext+'<br/>');
// //첫 t만 치환한다

//***************************************************************
//search(Value)
// 문자열 중 찾는 것에대한 속도는 가장빠르다,
// 유사 value가 있다면 value를 리턴함 metch(Value) /유사 해당 value의 index를 리턴함indexOf (없으면 -1)
// var a = 'Sindsdsd';
// var ac = a.search('s');
// //var ac = a.search('S','s',1); //인자를 추가한다고 여러개를 찾을 수는 없다.
// //var ac = a.search('S').search('i'); //메소드르 추가한다고 여러개를 찾을 수 없다.
// document.write(ac); // 4 //index 값을 출력한다.
// console.log(ac); // 4 //index 값을 출력한다.
// var b = a;
// var bc = b.search('q');
// document.write(bc); // -1 / 존재하지 않는다
// console.log(bc); // -1 / 존재하지 않는다


// var str = "Sinismy";
// var indexStr = str.search('s');
// document.write(indexStr);
// //값이있다면 해당 값의 index를 리턴한다 : 가장 속도가 빠르다

// var strobj = {name : 'Sinismy'};
// var indexStr2 = strobj.name.search('s');
// document.write(indexStr2);
// //Key는 불가능하지만, 값은 가능하다.

// var strArray = ["Sinismy"];
// var indexStr3 = strArray[0].search('s');
// document.write(indexStr3);
// //인덱스로 뽑으면 가능하다. for에 응용 가능할 수 도 있다

// var a = "abc";
// var b = a.slice(0,1);
// document.write(b);
// console.log(b);

// var a = "my Sin";
// document.write(a.substring(8,9));
// console.log(a.substring(8,9));

// var a = "ABCD";
// var b = a.toLowerCase()
// document.write(b);
// console.log(b);


//***************************************************************

//문자열 전부를 소문자로 변형한다 .toLowerCase()
//문자열 전부를 대문자로 변형한다 .toUpperCase()

//***************************************************************
//***************************************************************
//***************************************************************

//배열 Array

//***************************************************************
// 첫 배열.concat(뒤로 합칠배열)) 주어진 두 배열을 합쳐 하나의 '배열'로 만들 수 있다
// var array1 = [1,2,3,4];
// var array2 = [1,2,3,4];
// var array3 = [5,6];

// var newArray1 = array1.concat(array2);
// document.write(newArray1 + '<br/>');
// console.log(newArray1);
// //같은 값을 concat 합쳤을때 / 중복값 상관없이 들어가므로 비교하여 지워야한다. -for 사용

// var newArray2 = array1.concat(array3);
// document.write(newArray2+ '<br/>');
// console.log(newArray2);
// //array1 배열의 마지막 값 뒤로(index) 들어간다.

// var newArray3 = array3.concat(array1);
// document.write(newArray3[1]+ '<br/>');
// console.log(newArray3[0]);
//array3 배열의 마지막 값 뒤로(index) 들어간다. 동일

//***************************************************************
//join('배열사이를 연결할 문자')
// //주어진 구분으로 배열을 문자열로 합쳐서 리턴한다.

// var arr1 = [1,2,3];
// var arr2 = [1,2,3];
// var arr3 = [4,5];

// var newArr1 = arr1.join('-');
// document.write(newArr1+'<br/>');
// console.log(newArr1);
// document.write(newArr1[0]+'<br/>');
// //index 값으로 리턴가능하다.
// document.write(newArr1.length+'<br/>');
// //'-'를 포함하여 길이 리턴도 가능하다.

//***************************************************************
//pop() 배열의 마지막 원소를 제거하고, 제거한 원소를 리턴한다.

// var a = [1,2,3];
// var ap = a.pop();
// document.write(ap+'<br/>'); //3
// document.write(a+'<br/>'); //[1,2]

//***************************************************************
// Array.push('value') Array 배열에 마지막 원소에 value를 추가하고, 추가한 값을 리턴한다.

// var a = [1,2];
// var apush = a.push(3); 
// document.write(apush+'<br/>'); // 3
// document.write(a+'<br/>'); // [1,2,3]

//***************************************************************
//Array.reverse() Array 배열의 요소의 순서를 뒤짚는다.
// var a = [1,2];
// document.write(a +'<br/>'); //[1,2]
// var ar = a.reverse();
// document.write(ar+'<br/>'); // [2,1]
// document.write(a +'<br/>'); // [2,1]

//***************************************************************
//Array.slice(00번째 부터, 00번째 까지) 해당부분의 요소를 추출한다. 
//추출한 부분만 배열로 리턴한다.
// var a = [1,2,3,4,5];
// var asc = a.slice(0,1);
// document.write(asc+'<br/>'); // [1]
// document.write(a+'<br/>'); // [1,2,3,4,5]

//***************************************************************
//sort() 배열의 요소를 정렬하고 리턴한다
//정렬의 우선요소는 숫자의 크기 / 알파벳순서(문장일경우 첫글자 알파벳순서)
//가장 활용도가 높을 것 같은 배열의 메서드이다.

// var a = ['bbbb','c',3,5,1,'a',3];
// var ac = a.sort();
// document.write(ac);

//***************************************************************
//.splice(start, deleteCount, item1, item2, ...)
// const ArrayT = [1,2,3,4];
// ArrayT.splice(4, 0, 5); //index 4가 없지만 4번쨰자리를 만들면서 생성한다.
// ArrayT.splice(4, 4,'a'); // index 4부터 시작해서 요소 5를 지우고 a를 넣는다
// console.log(ArrayT);
//***************************************************************
//Date 날짜와 시간을 표시하는 객체
//현재 월 일 년 시간:분:초 국가 를 나타낸다. 날짜를 생성할때
// var tday = new Date();
// document.write(tday);

//***************************************************************
//getDate('지정된 날짜') 
// 지정된 날짜가 없다면 현재의 '일'을 가져온다.

// var today = new Date('Thu Aug 02 2018 16:05:41 GMT+0900 (한국 표준시)');
// var tt = today.getDate(); //날짜가 지정되어있다면
// document.write(tt+'<br/>'); // 일자에 해당하는 2 를 리턴한다.

// var tooday = new Date();
// var tto = today.getDate(); // 오늘날짜 8월 2일
// document.write(tto+'<br/>');  //따라서 오늘 일자인 2 를 리턴한다.

//***************************************************************
//getDay() 요일의 정보
//(현재 또는 지정) 요일을 일요일(0) ~ 토요일(6)까지 index number으로 리턴한다.
// var a = new Date();
// document.write(a.getDay());

//***************************************************************
// var a = new Date();
// a.getMonth(); //월
// a.getFullYear(); //4자리 연도
// a.getYear(); //2자리 연도
// a.getMinutes(); //분
// a.getSeconds(); // 초
// a.getMilliseconds(); //밀리
//***************************************************************
//***************************************************************
//***************************************************************
//Math 수학관련 메서드

//Math.abs(int) 절대값을 나타냄 단, 배열, 객체 등 에서는 제한이있음
// function plus(a,b){
//     return Math.abs(a+b);
// }
// document.write(plus(-2,-1)); // 3

// //예외처리 중요***************************************************************************************************************
// //숫자
// Math.abs(1); // 1
// Math.abs(-1); // 1
// //배열
// Math.abs([]); // 0
// Math.abs([1]); // 1 
// Math.abs([1,2]); // NaN
// //객체
// Math.abs({}); // NaN
// Math.abs({a:1}); //NaN
// //문자
// Math.abs(''); // 0
// Math.abs('String'); //NaN
// //없음
// Math.abs(null); // 0
// Math.abs(undefined); //NaN

//***************************************************************
//Math.cell(x) x를 올림하여 숫자로 리턴한다.
//받은 값 또는 사용할 값이 소수자리일때 올림하여 사용할 수 있다.

// var a = Math.ceil(0.1);
// console.log(a); // 1
// console.log(typeof a); // number

//***************************************************************
//Math.floor() 소수점이하 내림
//받은값 또는 사용할 값을 내림하여 활용 가능 /랜덤 숫자
// console.log(Math.floor(1.111));

//***************************************************************
//Math.Max(x,z,y); 3개 중 최대값
//Math.Min(x,z,y); 3개 중 최소값

//***************************************************************
//Math.random(); 0부터 1까지의 임의 수를 리턴한다.
// console.log(Math.floor(Math.random()*10 )); //1~10 사이 임의 수 를 리턴하는 방식

//***************************************************************
//Math.round(x); x의 값을 반올림한다.
// console.log(Math.round(0.45)); //0
// console.log(Math.round(0.5)); //1
//***************************************************************


//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************
//***************************************************************




</script>

<!-- 러닝 자바스크립트 -->
<script>
//*****************************************************************
//제어문과 연산자
// document.write('if - else 체인 연결하기');
// if(true){
//     console.log('트루');
// }
// else if(true){
//     console.log('트루2');
// }
// else{
//     consolo.log('거짓');
// }
// //*********
// document.write('while 기초');
// const i = 1;
// while(i === 1){
//     console.log('i는 1이다');
//     break;
// }
// //*********
// document.write('do ~ while 기초');
// let a = 1; //const a = 1 은 a가 무조건 1이여야한다.
// do {
//     console.log(a); //무조건 한번 실행된다.
//     a++;            //무조건 한번 실행된다.
//     }
// while(a < 3); //아닐때 까지 실행하는 조건
// console.log(a); //마지막 실행했던 3의 값도 들고있다
// //*********
// document.write('for 기초');
// for(var t = 1; t<3; t++){
//     console.log(t+'번째 T를 찍는 for');
// }
// console.log(t); //t는 마지막 3의 값까지 들고있다.
// //*********
// //for loop 중 조건을 여러가지 설정할 수있다 / 가독성 주의
// for(let temp, i=0, j=1; j<10; temp = 1, i=j, j = i + temp){ //let 선언으로 for 밖에서 값에 접근 불가능하다.
//     console.log(j+'for , 를 사용한 여러가지 조건 설정');
// }

// //for 무한루프 주의 사항
// //for(){ console.log(a)} /for에서 조건이 없다면 무한루프가 발생한다.

// //for 리턴값없이 사용 가능하다.
// for(let i = 1; i<2; i++) //내부에서 작동만한다.

// //for 의 조건으로 객체프로퍼티를 사용할 수 있다. /단, ;앞뒤에 세미콜론을 찍을 것;
// var play = {
//     isBroke : 3,
// }

// for(; play.isBroke === 1;){
//     console.log(play.isBroke);
//     break;
// }

//for과 while은 바꿀 수 있다.
//while은 제어할 객체를 루프 밖에 선언하므로 제어를 하는 객체를 쉽게 찾을 수 있다
//for 은 제어할 객체와 조건을 한줄에 사용하여 쉽게 찾을 수 있다.ㄴ

//또다른 if 루프 / switch(expression)) - case - default
// const piB = play.isBroke;
// switch(piB){
//     case 1: console.log(piB); //1 일때
//     break;
//     case 2 : console.log('piB 값이 틀림') //2 일떄
//     break;
//     default : console.log('고정값'); // 1,2 아닐때
//     break;
// }

//*********
//for in 객체의 프로퍼티에 루프  / 
// const user1 = {
//     name:'kim',
// }

// for(let a in user1){ //생성된 a 가 키로 돌면서 값을 출력한다.
//     console.log(user1[a]);
// }

//*********
//ES6 새로운 문법
//for of 객체와 배열의 요소에 루프를 실행한다
// const b = [1,2,3,4];
// for(let c of b){
//     console.log(`${b}`); //1 2 3 4
// }

//********
//배열을 수정할때에는 가급적 감소하는 인덱스를 사용하자

// let bigArray = [1,2,3,4]
// for(let i = 0; i < bigArray.length; i++){
//     if(bigArray[i] < 5){
//         bigArray.splice(i,i,'a');
//         console.log(bigArray);
//         console.log(i + '1번마');
//     }
// }

// let bigArray2 = [1,2,3,4];
// for(let i = bigArray2.length - 1; i >= 0; i--){
//     if(bigArray2[i] < 5){
//         bigArray2.splice(i,1,'a');
//         console.log(bigArray2);
//         console.log(i);
//     }
// }

//*********
//변수할당을 위한 if/else 라면 
// const label = isPromise(n) ? 1 : 2;
//     구할변수   조건      true false

//*********
//객체와 배열 해체 
// const a = {name:'kim',}
// const {name} = a;
// console.log(name);

// document.write(a + '<br/>');
// document.write(a.name + '<br/>');
// document.write('');
// document.write('');

// const b = [1,2,3];
// const [q,w,e] = b;
// console.log(q);
//*****************************************************************
//함수
//기초 선언
// function getGreetings(){
//     return console.log('Hello world');
// }

// const getRedthings = () =>{
//     console.log('Hello World');
// }

// getGreetings(); //함수 호출 /괄호가 있다면
// getRedthings; //함수 참조 / 괄호가 없다면

// const getYello = getRedthings; //다른 이름으로 함수를 참조하여 호출할 수 있다.
// getYello(); //Red 에서 Yello로 변경

// //*********
// //객체 프로퍼티에 함수 할당할 수 있다.
// const funcCC = {
//     name, //빈 객체 프로퍼티를 만들고
// }

// funcCC.name = getYello; //비어있는 프로퍼티에 함수를 참조하여
// funcCC.name(); //함수를 호출할 수 있다.

// //*********
// //배열의 요소로 함수를 할당할 수 있다.
// const arr = [1,2,3]

// arr[1] = getYello; //2번째 요소에 함수를 참조하였다.
// console.log(arr); // 1,f,3
// arr[1]();//괄호가 있다면 함수라고 호출한다
//arr[2]();// 함수를 참조하고 있지 않기 떄문에 오류이다.

//*********
//원시객체와 객체는 함수안과 밖에서 어떻게 다른가


// let o = {
//     msg : '초기값',
// } //객체 선언
// const f = (o) =>{
//     return o.msg = `f안에서 수정함 ${o.msg}`;
// } //함수 선언

// console.log(o.msg); //함수 적용전
// f(o);//함수 실행
// console.log(o.msg);//함수 실행 후

//*********

// const func1 = (x) =>{
//     return `in func : x = ${x}`;
// }

// console.log(func1()); //x = undefinen
// console.log(func1(1)); //x = 1
// console.log(func1(1,2,3)); //x = 1

// //*********
// //함수의 매개변수로 받는 객체를 해체하여 사용할 수 있다.
// const a ={
//     name : 'I',
//     what : 'Love',
//     who : 'Sin'
// }

// const func2 = ({name, what, who}) =>{
//     return `${name} ${what} ${who}`
// }

// console.log(func2(a));//a 객체를 통으로 집어넣었다.

//*********
//배열의 요소도 해체하여 매개변수로 넣을 수 있다.
// const func3 = ([name2, what2, who2]) => { //매개변수로 배열의 요소를 해체하였다. //배열의 요소해체는 순서대로 들어간다.
//     return `${name2} ${what2} ${who2}`;
// }

// const arr = ['My','Wife','Sin']; //배열의 요소
// console.log(func3(arr)); //함수에 배열을 통으로 넣었다.
// //*********
// const func4 = ([...x]) =>{
//     return `${x}`;
// }

// const arr2 = ['My','Wife','S.T.Y']; //배열의 요소

// console.log(func4(arr2));

//*********
//ES6 부터 매개변수는 기본값을 갖을 수 있다.
// const defaultArg = (a, b="default를 갖는다", c = 3) =>{
//     return `${a} + ${b} + ${c}`
// }

// console.log(defaultArg(1,2,3)); //1,2,3
// console.log(defaultArg(1,2)); //1,2,3
// console.log(defaultArg(1)); //1,default를 갖는다,3

//*********
//객체의 프로퍼티가 변수라면 -> 프로퍼티
//객체의 프로퍼티가 함수라면 -> 메서드
//함수를 프로퍼티에 참조시켜서 하는 방법 외 ES6만의 방법이 생김 (참조: const a = () =>{} / o.name  = a; /)

// const o1 = {
//     name : 'kim',
//     what : function(){
//         console.log(o1.name);
//     }
// }

// //변경
// const o2 ={
//     name:'kim',
//     what(){
//         console.log(o2.name);
//     }
//     //함수의 이름과 프로퍼티의 이름이 동일하게 갖을 수 있다.
// }

// o1.what();
// o2.what();
// //동일하다.

//****중요**************************************************************************************************************
//this의 사용
//this를 묶는 화살표 함수와 call

// const bruce = { name : 'Bruce'};
// const madeline ={name : 'MadeLine'};

// function greet(){
//     return `Hello, I'm ${this.name}`;
// }

// //call을 사용하면 call의 arg로 this를 묶어준다.
// console.log(greet());
// console.log(greet.call(bruce));
// console.log(greet.call(madeline));

// function updatefunc(birth, occpation){
//     this.birth = birth;
//     this.occpation = occpation;
// }

// //*********
// //apply 일반적인 call과 비슷하다 /Math.max, Math.min
// //apply는 매개변수를 배열로 받는다.
// updatefunc.call(bruce, 1992, 'proG');
// //this를 넣을 매개변수 / 지정할 매개변수 / 단 일반입력
// console.log(bruce);

// updatefunc.apply(bruce, [1992, 'programer']);
// //this를 넣을 매개변수 / 지정할 매개 변수 /배열로 입력
// console.log(bruce);

// //apply의 할용
// const arr = [1,2,3,4,5];
// const arrMax = Math.max.apply(null, arr);
// //Math.max 메서드에 apply 하여 배열을 넣고(this가 뭐든 상관없기에 null)  
// console.log(arrMax);
// const arrMin = Math.min.apply(null, arr);
// //Math.min 메서드에 apply 하여 배열을 넣고(this가 뭐든 상관없기에 null)  
// console.log(arrMin);

// //*********
// //Bind 함수의 this를 고정하여 call or apply가 적용되지 않는다.
// const updateBruce = updatefunc.bind(bruce);
// console.log(bruce);

// updateBruce(1992, 'actor');
// console.log(bruce);
// updateBruce.call(madeline, 1999, 'Sin');
//console.log(bruce); //name이 변하지 않았다. //따라서 이름을 고정하고 나이와 직업은 바꿀수 있는 함수를 만들고 싶을때 Bind가 유용하다
//단, 찾기 힘든 에러의 원인이 될수도 있다.

//*********
//배열의 기초
//배열은 본질에서 순서가 있는 집합이며, 0부터 시작하는 숫자형 index를 사용한다.
//배열은 비균질적(통일되지않은 여러 형태의 집합, 즉 다른타입 가능)
//배열의 길이보다 큰 인덱스를 할당하면 그사이 값은 undefined가 된다.

// //배열 리터럴
// const arr1 = [1,2,3];
// const arr2 = ['one', 'two', 'three'];
// const arr3 = [[1,2,3], ['one',2,'three']];
// const arr4 = [
//     {name : 'kim'},
//     [{age:27, sex:'M'}],
//     [1,2,3],
//     'one',
//     1
// ];

// //배열 요소에 접근하기
// console.log(arr1[0]);
// console.log(arr2[1]);
// console.log(arr3[1][0]); //index 1에서 deps 2 index 0
// console.log(arr4[1][0]); //1
// console.log(arr4[0]);
// console.log(arr4[2][0]);

// //배열의 길이구하기
// console.log('--------');
// console.log(arr1.length); //3
// console.log(arr2.length); //3
// console.log(arr3.length); //2
// console.log(arr4.length); //5

// //배열 길이 늘리기
// arr1[4] = 10; //할당하여 늘렸기때문에 가능하다.
// console.log(arr1); //[1, 2, 3, empty, 10]
// console.log(arr1[3]); //undefined

// arr2[4]; //늘리기만 했기때문에 아무런 변화가 없다.
// console.log(arr2);

// //배열 생성자는 넘어갑니다.

//*********
//배열의 요소조작 - 배열 자체를 수정 / 새로운 배열을 리턴

//배열의 처음 요소 하나 추가/삭제
// console.log('배열의 처음 요소 하나 추가/삭제')
// const arr1 = [1,2,3,4];

// arr1.unshift(0); //.unshift(맨앞에 추가할 값);
// console.log(arr1);

// arr1.shift(); //맨앞의 값을 무작정 삭제
// console.log(arr1);

// //배열의 마지막 요소 추가/삭제
// arr1.push(5); //.push(마지막에 추가할 값)
// console.log(arr1);

// arr1.pop(); //마지막 요소 무작정 삭제
// console.log(arr1);

// //배열의 끝에 어려 요소 추가하기
// console.log('배열의 끝에 어려 요소 추가하기')
// const arr2 = ['a','b'];
// const arr3 = arr1.concat(arr2);
// console.log(arr1 + ' : concat 변하지 않는다');
// console.log(arr2 + ' : concat 변하지 않는다');
// console.log(arr3);

// //배열 일부 가져오기
// const arr4 = arr1.slice(0,3) //0부터 3-1 까지 구한다.
// console.log(arr4);

//배열의 임의의 위치에 추가 또는 제거
// const arr1 = [1,2,3,4];
// console.log(arr1);
// arr1.splice(1,0,10);
// console.log(arr1); //기존 배열 자체를 바꾼다.

//배열 안에서 요소 교체하기
// const arr1 = [1,2,3,4];
// arr1.copyWithin(1,2,3);//.copyWithin(넣을 위치, 복사를 시작할 위치, 복사를 끝낼 위치-1까지);
// console.log(arr1); //음수인덱스 사용 가능하며, 세번째 끝낼위치는 생략가능

//특정값으로 기존배열의 요소를 채우기(일부 채우기)
// const arr1 = [1,2,3,4];
// arr1.fill('a');
// console.log(arr1);
// arr1.fill('b',1,3);//.fill(채울값, 채우기시작할위치, 끝낼위치-1까지)
// console.log(arr1);

//배열의 정렬과 역순
// const arr = [1,2,3,5,4];
// arr.reverse();
// console.log(arr);
// arr.sort();
// console.log(arr);

// console.log('sort는 함수를 받을 수 있다. 응용');
// const arr2 = [{name:'kim', age:27}, {name:'sin', age:26}, {name:'dana', age:26}];
// arr2.sort();
// console.log(arr2);

// arr2.sort((a,b) => //매개변수로 주어진 숫자만큼 들어온다.
//     a.name > b.name //name 프로퍼티의 첫번째 알파벳 순서 / 기본값
// )

// console.log(arr2);

// arr2.sort((a,b) => //매개변수로 주어진 숫자만큼 들어온다.
// a.name[2] > b.name[2] //name의 세번째 알파벳 순서로
// )
// console.log(arr2);

//*********
//배열 검색
//요소가 있다면 index값을 반환하며 / 없으면 -1 값을 반환하는 메서드
//.indexOf(앞부터 찾는값), lastIndexOf(뒤부터 찾는값), findIndex(찾는값)
// const arr = [1,2,3,4,'a',{name:'kim'}];
// const arrindex = arr.indexOf(1);
// console.log(arrindex); //처음부터 찾는다.
// const arrlast = arr.lastIndexOf('a');
// console.log(arrlast); //역뱡향으로 찾는다.

// const arrFindIndex = arr.findIndex((o) => o.name === 'kim'); //findIndex에는 개체의 요소자체를 찾아서 인덱스를 반환할때 사용되며, 함수형으로 찾는다.
// console.log(arrFindIndex);

// const arrFind = arr.find( (o) => o.name === 'kim'); //객체 자체를 찾아서, 내용을 반환한다, 콜백함수로 찾는다.
// console.log(arrFind);
// const arrFind2 = arr.find( (a,b) => a > 2 && Number.isInteger(Math.sqrt(a)) )
// console.log(arrFind2); //4

//*********
// //조건에 맞는 요소를 찾는 즉시 멈추는 some / 모든 조건이 맞아야 찾는 every
// const arr = [1,2,3,4,'a',{name:'kim'}];
// // const arrSome = arr.some((x) => x.name === 'kim'); //조건이 맞으면 true
// // console.log(arrSome);

// const arrEver = arr.every( x => x !== 0 ); //모든 요소가 조건을 맞춰야한다.
// console.log(arrEver);

//*********
//일정한 형식의 배열을 다른형식으로 바꾼다 map
// const arr = [{name:'kim',wife:'sin'}, {name:'hong',wife:'lee'}];
// const arrMapW = arr.map( a => a.wife) //.map(요소자체, 요소인덱스))
// console.log(arrMapW);
//                                 //{name:'kim'}, {wife:'lee'}, 2
// const arrMapN = arr.map( a => a.name) //.map(요소자체, 요소인덱스))
// //Kim Hong
// console.log(arrMapN);

// const arryWM = arrMapN.map( (x, i) => x + arrMapW[i]);
//                         //kim / 0 /sin
//                         //hong / 0 /lee
// console.log(arryWM); //[kimsin, honglee]

// //배열의 요소를 변형 filter
// const cards = [];
// for(let suit of ['H','S','C','D']){
//     for(let value = 1; value < 13; value ++){
//         cards.push({suit, value}); //배열에 객체로 넣어야 프로퍼티를 사용하여 분리할 수 있다.
//     }
// }
// console.log(cards); // [H~D]]과 1~13까지의 조합

// const cardDeck = cards.filter(x => x.value === 2);
// console.log(cardDeck);
// const cardDeck1 = cards.filter(x => x.suit === 'H' && x.value === 2);
// console.log(cardDeck1);

//*********
//배열의 마법 reduce : 배열자체를 변형

//*********
//*********
//*********
//*********
//*********
//*********

</script>

<!-- 노드 Js 교과서 -->
<script>
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //Node.JS 교과서 ES6
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
        //***************************************************************
    
         //논블로킹 방식
        // function longRunningTask(){
        //     //오래 걸리는 작업
            
        //     console.log('작업 끝');
        // }

        // console.log('시작');
        // setTimeout(longRunningTask, 0); //논블로킹을 만들기 위한 기법 중 하나
        // console.log('다음 작업 시작');    

        //2강 ESCMA 5 -> 6
            //객체 리터럴의 변경
            //ES5 ver
        //     var sayNode = function(){
        //         console.log('node.Js');
        //     };

        //     var es = 'ES';
            
        //     var oldObject = {
        //         sayJs : function(){
        //             console.log('JS');
        //         },
        //         sayNode : sayNode,
        //     }

        //     oldObject[es + 6] = 'Fantastic';

        //     oldObject.sayNode();
        //     oldObject.sayJs();
        //     console.log(oldObject.ES6);

        // /************** -> ES2015*******************/
        //     var sayNode = function(){
        //         console.log('node.Js');
        //     };

        //     var es = 'ES';

        //     const newObject = {
        //         sayJs(){ //sayJs : function(){...} 
        //             console.log('Js 2')
        //         },
        //         sayNode, //sayNode : sayNode
        //         [es + 6] : 'Fantastic 2', //newObject[es + 6] : 'Fantastic 2' / 동적으로 변경
        //     }

        //     newObject.sayNode();
        //     newObject.sayJs();
        //     console.log(newObject.ES6);

        //***************************************************************
            //배열의 값을 반복하기 위한 forEach(callbackName)
            //하나의 값만 callback 함수의 인자로 들어가게 된다.
            //배열의 값과 + 외부의 변수 사용가능
    
            // function logset(value1,value2){
            //     console.log(`s[${value1}] = ${value2}`)
            // }
            
            // new Set(['foo','boo']).forEach(logset); //두개의 인수를 동일하게 만들어서 하나씩만 반복한다.
            // //출력 s[foo]=foo / s[boo]=boo
            
            // const name = 'Doyle'
            // const vlaue = ['kim', 'sin', 'J'];
            
            // function nameSelect(val){
                //     document.write(name + val);
                // }
                
                // vlaue.forEach(nameSelect); //DoyleKim Doylesin DoyleJ
    
        //***************************************************************
        // //Set은 중복을 허용하지 않는 데이터 집합이다. /배열이다
        // const newSet = new Set();
        
        // newSet.add
        
        // console.log(newSet);
        
        // new Set(['foo', 'boo', undefined, null,0]).forEach(logset); 
        
        
            
        //***************************************************************
        //비구조화 할당(destructuring)
        //객체 {} 또는 배열 [] 의 값을 변수에 담을때 편리하다
        //단, 함수의 this는 유의하자. /화살표 함수 내용 참조
    
        // const person = {
        //     name : 'kim',
        //     height(){
        //         console.log( this.name + (100 + 80));
        //     }
        // }
        
        // const {name, height} = person;
        // console.log(name);
        // height() + console.log('함수의 this가 name의 값을 못 찾아서 kim을 출력할 수 없다.'); 
        // person.height() + console.log( ` : 함수의 this를 위해 기존과 동일하게 출력해보았다`);
    
        // const arrayTest = [1,2,{},true,function a(){console.log('a')}];
        // const [int1 , int2, Obj , bool] = arrayTest; //없으면 비워두면된다
        // console.log(int1);
        // console.log(int2);
        // console.log(Obj);
        // console.log(bool);

        // 나머지를 한번에 넣고싶다?! ... 을 사용하면 된다 '...'스프레드 레스트 rest 는 나머지 또는 모든것을 의미한다.
        // const arraytest2 = ['nodeJs', 1, {}, false ];
        // const [node, , ...obz] = arraytest2; //node는 nodeJs / 1은 빈칸이므로 지정하지않았다 / ...obj 는 ...으로 인해 나머지 원소들 {}, false 를 담았다.
        // console.log(node); // nodeJs
        // console.log( ); //아무것도 없다
        // console.log(obz); //[{}, false]
        //***************************************************************
        // ... 스프레드 레스트 rest
        // const m = (x, y) => console.log(x, y);
        // m(1,2);
        
        // const n = (z, ...i) => console.log(z, i);
        // n(1,2,3,4,5,6); //i로 받는 나머지 것들은 배열로 받는다. rest
        // //ES5 에서는 유사배열 이였으나 rest는 배열이므로 메서드 사용도 가능하다. /활용하면 좋다
        //***************************************************************
        //콜백 지옥탈출 프로미스 Promise
        //대문자이면 생성자이다
        // const conditon = 1;
        // //프로미스는 만드는 방법이있다, resolve 는 true일때 / reject는 실패일때
        // const promise = new Promise((resolve, reject) => {
        //     if(conditon === 1){
        //         resolve('인증');
        //     }
        //     else{
        //         reject('인증실패')
        //     }
        // })

        // promise
        //     .then((suc) => {
        //         console.log('성공');
        //     })
        //     .catch((faill)=>{
        //         console.log('실패');
        //     });

        //전체를 검증할때 , promise.all([조건1,조건2,조건3]); 을 넣을 수 있다.
        //.then((result)=>{})
        //.catch((err) => {})
        //단, 세가지 경우 전부 성공해야만 한다. 두가지 성공하고 하나만 실패여도 성공한 내용까지 실패에 담긴다.
        //***************************************************************
        //***************************************************************
        //나중에 다시 보자
        //***************************************************************
        //***************************************************************
        //promise 보완 async !!!!
        // function 앞에 async를 붙여야 한다. async function aa(){} /익명함수도 동일

        // User.findOne('kim')
        // .then((user) => {
        //     console.log(user); //then의 위치를 바꿀 수 없다. then ->다음 -> catch가 와야한다.
        // })
        // .catch((err) => {
        //     console.log(err); //catch의 위치를 바꿀수 없다.
        // })
        // console.log('다찾았니? // 부분이 가장처음 실행 되는 것이 문제이다.')
        
        // //보완 async
        
        // const func = async(user) => {
        //     try{
        //         const user = await User.findOne('kim');
        //         console.log(user);
        //         const updateUser = await User.updateUser('kim','sin');
        //         console.log(updateUser);
        //     }
        //     catch(err){
        //         console.log(err);      
        //     }
        //     //개별적으로 잡기위해서는 try-catch를 각자 입력해야된다.
        // }
        //***************************************************************
        //AJAX /웹에선 ES6가 잘 돌아가지 않을 수 도 있다.
        //GET 방식으로 XML사용
        //이벤트 리스너 onreadystatechange 를 사용함
        // var xhr  = new XMLHttpRequest();
        // xhr.onreadystatechange = function(){
        //     if(xhr.readyState === xhr.DONE){
        //         if(xhr.status === 200 || xhr.status === 201){
        //             console.log(xhr.responseText);
        //         }
        //         else{
        //             console.log(xhr.responseText);
        //         }
        //     }
        // };
        // xhr.open('GET', 'https://www.zerocho.com/api/get');
        // xhr.send();
        // 가져온 값 : {}
        
        //onload / onerror 메서드 사용
        // var xhr = new XMLHttpRequest();
        // xhr.onload = function(){
        //     if(xhr.status === 200 || xhr.status === 201){
        //         console.log(xhr.status + ' 성공 : ' + xhr.responseText );
        //     }
        // };
        // xhr.onerror = function(){
        //     console.error(xhr.responseText)
        // };
        // xhr.open('GET','https://www.zerocho.com/api/get');
        // xhr.send();
        //200 성공 : {}

        //POST 방식 - onreadystatechange 이벤트 리스너 사용
        // var xhr = new XMLHttpRequest();
        // var data = {
        //     name : 'kim',
        //     height : 173,
        // };
        // xhr.onreadystatechange = function(){
        //     if(xhr.readyState === xhr.DONE){
        //         if(xhr.status === 200 || xhr.status === 201){
        //             console.log(xhr.responseText);
        //         }
        //         else {
        //             console.error(xhr.responseText);
        //         }
        //     }
        // };
        // xhr.open('POST','https://www.zerocho.com/api/get')
        // xhr.setRequestHeader('Content-Type', 'application/json');
        // xhr.send(JSON.stringify(data));
        // //POST 방식은 오류다. 10.7장 에서 배울예정
        //***************************************************************
        //FormData AJAX 에서 Form 태그를 동적으로 제어할 수 있는 기능
        //AjAX에서 xhr.send(formData); 를 담아 보낸다.
        // const formData = new FormData();
        // formData.append('name', 'kim'); //append 배열에 추가한다 ('키', '값')을
        // formData.append('wife','sin');
        // formData.append('sun', 'kimc');
        // console.log(formData.has('name'));
        // console.log(formData.has('kim')); //has 찾는다 ('키')를 / 있으면 true / 없으면 false
        // console.log(formData.has('wife'));
        // console.log(formData.get('kim'));
        // console.log(formData.get('name')); //가져온다 get ('키')의 값을 // 없으면 null
        // console.log(formData.get('wife')); //있으면 값이 출력 된다.
        
        // formData.append('test', ['lee','kang']);
        // console.log(formData.get('test')); //배열도 넣을 수 있다 / 없으면 null

        // formData.delete('test'); //키에 해당하는 값을 지운다.
        // console.log(formData.get('test'));

        // formData.append('ee','ii','dd','yy'); //불가능
        // console.log(formData.getAll('ee'));
        
        // formData.set('ee', 'dev'); //수정한다. 키, 에해당하는 값을
        // console.log(formData.get('ee'));
        //***************************************************************
        // //작성된 formData를 AJAX를 통해 서버에 보내면 된다.
        // var xhr = new XMLHttpRequest();
        // var formData2 = new FormData();
        // formData2.append('name', 'kim');
        
        // xhr.onreadystatechange = function(){
        //     if(xhr.readyState === xhr.DONE){
        //         if(xhr.status === 200 || xhr.status === 201){
        //             console.log(xhr.responseText);
        //         }
        //         else{
        //             console.error(xhr.responseText);
        //         }
        //     }
        // };
        // xhr.open('POST', 'https://www.zerocho.com/api/post/formdata');
        // xhr.send(formData2);
        
        // var xhr = new XMLHttpRequest();
        // var formData2 = new FormData();
        // formData2.append('name', 'kim');
        
        // xhr.onreadystatechange = function(){
        //     if(xhr.readyState === xhr.DONE){
        //         if(xhr.status === 200 || xhr.status === 201){
        //             console.log(xhr.responseText);
        //         }
        //         else{
        //             console.error(xhr.responseText);
        //         }
        //     }
        // };
        // xhr.open('GET', 'https://www.zerocho.com/api/search/'+encodeURIComponent('노드')); //받는쪽은 decodeURIComponent('변환된 코드의 값')
        // //한글을 처리하기 위해서 사용한다.
        // xhr.send();
        //***************************************************************
        //노드를 웹서버로 사용하는 경우, 프론트와 데이터를 주고 받는 방법
        //서버에서 보내준 정보를 프론트에서 어디에 넣어야할 지 정할 수 있다.
        // 태그의 Id와 내용에 data- 로 시작되는 내용이있다.
        // 이것을 넣어야 받는 곳을 알 수 있다.
        //또는 dataset 에 데이터를 넣어도 HTML 태그에 반영된다.
        //이것을 data attribute와 data set 이라고 한다.
        //***************************************************************
        //***************************************************************
        //3강 노드모듈은 module.export = {nodeJsF};
        //const {nodeJsF} = requir(./nodeJsF.js) 에서 다루도록한다
        //***************************************************************
        //***************************************************************

</script>




<!-- //프로미스 예제 Line : 589 // 텍스트에 입력하면 아래 p태그(id="clickValue")에 넣는다. -->
    <!-- <input type="text" id="inputName" onkeydown="keyEnter();" value>
    <input type="button" onclick="btName();" value="인증시작">

    <p>인증값</p>
    <p id="clickValue"></p>

<script>

    const keyEnter = () => {
            if(event.keyCode === 13){ //enter keyCode 13
                btName();
            }
        }

    const btName = () => {
         let x = document.getElementById('inputName').value;
        document.getElementById('clickValue').innerText = x;
         
        const promise = new Promise((resolve, reject) =>{
            const y = document.getElementById('clickValue').innerText;
            console.log(y + ': Y');
            if( y === "dt"){
                resolve('suc');
             }
            else{
                reject('miss');
            }
        });
        
        promise
        .then((succ) => {
            return console.log('도트 확인');
        })
        .catch((misss)=>{
            return console.log('누구세요');
        });
        console.log('인증 실행');
    } 

    </script> -->
<!-- <script type="text/javascript">
    function changeRadio(obj){
        obj.getAttribute('for')=='r2' ? obj.setAttribute('for', 'r1') : obj.setAttribute('for', 'r2');
    }
    </script>
    <style type="text/css">
    label {
        cursor: pointer;
        text-decoration: underline;
    }
    </style>
    </head>
    
    <div>
    <input type="radio" name="r" id="r1" value="" checked> 라디오버튼 1
    <input type="radio" name="r" id="r2" value=""> 라디오버튼 2<br>
    <label for="r1" onclick="changeRadio(this)">Change</label>
    </div> -->

<!-- Line : 755 나중에 참조하는 것으로.... 프론트와 백엔드 간의 데이터 통신 방법이다
    <div data-id="" data-user-job="programmer"></div> -->


</body>
</html>
